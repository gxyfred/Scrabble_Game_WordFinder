// Name: Xiaoyu Gao
// USC NetID: xiaoyuga
// CS 455 PA4
// Fall 2018

import java.util.*;

/**
 class Rack
 This class contains method that correlate to our rack, including getting all combos of string from
 user's input rack, and show the word list that can generated by rack in a specific order.
 */

public class Rack {

    /**
     method getAllCombos
     This method can get all combos of string from a user's input rack by using allSubsets method, and
     then return an arrayList.
     */
    public ArrayList<String> getAllCombos(String s) {

        // Firstly, use a map to store the component in the rack, like how many 'a' in the rack or 'b' or 'c'...
        Map<Character, Integer> rackComponent = new HashMap<Character, Integer>();
        for(int i = 0; i < s.length(); i++) {  // Use for loop to go through the input rack.
            char alphabet = s.charAt(i);
            int alphabetCount = 0;
            if(rackComponent.containsKey(alphabet)) {
                alphabetCount = rackComponent.get(alphabet) + 1;
            } else {
                alphabetCount = 1;
            }
            rackComponent.put(alphabet, alphabetCount);
        }

        // Secondly, store the alphabets that show in rack in a string, and store the frequency of those alphabets in an integer array.
        String unique = "";
        int[] mult = new int[rackComponent.size()];
        int index = 0;

        for(Map.Entry<Character, Integer> entry : rackComponent.entrySet()) {
            unique = unique + entry.getKey();
            mult[index] = entry.getValue();
            index++;
        }
        int kValue = 0;

        // Finally, use allSubsets method to generate all the combos and return as an arrayList.
        return allSubsets(unique, mult, kValue);

    }

    /**
     method showList
     This method can show an arrayList in a specific order by using comparator.
     */
    public void showList(ArrayList<String> myList) {

        // Firstly, calculate the value of each word, and store the word with its value in a map.
        Map<String, Integer> valueMap = new TreeMap<String, Integer>();
        for(int i = 0; i < myList.size(); i++) {
            valueMap.put(myList.get(i), getStringValue(myList.get(i)));
        }

        // Then we use a list and override its cimparator to sort the entries in the previous map.
        List<Map.Entry<String, Integer>> list = new ArrayList<Map.Entry<String, Integer>>(valueMap.entrySet());
        Collections.sort(list, new Comparator<Map.Entry<String, Integer>>() {
            @Override
            public int compare(Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) {
                if(o1.getValue().equals(o2.getValue())) {      // If two entries have the same value, then sort them alphabetically.
                    return o1.getKey().compareTo(o2.getKey());
                } else {      // If two entries don't have the same value, then entry with higher value should be in front of the lower one.
                    return -o1.getValue().compareTo(o2.getValue());
                }
            }
        });

        // Finally, print out the sorted list as our output.
        for (Map.Entry<String, Integer> mapping : list) {
            System.out.println(mapping.getValue() + ": " + mapping.getKey());
        }

    }

    /**
     Finds all subsets of the multiset starting at position k in unique and mult.
     unique and mult describe a multiset such that mult[i] is the multiplicity of the char
     unique.charAt(i).
     PRE: mult.length must be at least as big as unique.length()
     0 <= k <= unique.length()
     @param unique a string of unique letters
     @param mult the multiplicity of each letter from unique.
     @param k the smallest index of unique and mult to consider.
     @return all subsets of the indicated multiset
     @author Claire Bono
     */
    private static ArrayList<String> allSubsets(String unique, int[] mult, int k) {
        ArrayList<String> allCombos = new ArrayList<>();

        if (k == unique.length()) {  // multiset is empty
            allCombos.add("");
            return allCombos;
        }

        // get all subsets of the multiset without the first unique char
        ArrayList<String> restCombos = allSubsets(unique, mult, k+1);

        // prepend all possible numbers of the first char (i.e., the one at position k)
        // to the front of each string in restCombos.  Suppose that char is 'a'...

        String firstPart = "";          // in outer loop firstPart takes on the values: "", "a", "aa", ...
        for (int n = 0; n <= mult[k]; n++) {
            for (int i = 0; i < restCombos.size(); i++) {  // for each of the subsets
                // we found in the recursive call
                // create and add a new string with n 'a's in front of that subset
                allCombos.add(firstPart + restCombos.get(i));
            }
            firstPart += unique.charAt(k);  // append another instance of 'a' to the first part
        }

        return allCombos;
    }

    /**
     method getStringValue
     This method can get the value of a string by adding all the alphabet values.
     */
    private int getStringValue(String s) {

        ScoreTable score = new ScoreTable();
        int sumValue = 0;

        for(int i = 0; i < s.length(); i++) {
            sumValue += score.getScore(s.charAt(i));
        }
        return sumValue;

    }

}
